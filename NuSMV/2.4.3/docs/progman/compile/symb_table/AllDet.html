<html>
<head><title>The  package: all functions </title></head>
<body>


<HR>
<DL>
<dt><pre>
<A NAME="SymbCache_create"></A>
SymbCache_ptr <I></I>
<B>SymbCache_create</B>(
  SymbTable_ptr  <b>symb_table</b> <i></i>
)
</pre>
<dd> Callable only by the SymbTable instance that owns self.
  The caller keeps the ownership of given SymbTable instance
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_destroy"></A>
void <I></I>
<B>SymbCache_destroy</B>(
  SymbCache_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Callable only by the SymbTable instance that owns self.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_constants"></A>
NodeList_ptr <I></I>
<B>SymbCache_get_constants</B>(
  const SymbCache_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returned instance belongs to self, do not destroy or 
  change it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_define_body"></A>
node_ptr <I></I>
<B>SymbCache_get_define_body</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns the body of the given DEFINE name
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_define_context"></A>
node_ptr <I></I>
<B>SymbCache_get_define_context</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns the context of the given DEFINE name
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_define_flatten_body"></A>
node_ptr <I></I>
<B>SymbCache_get_define_flatten_body</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns the flattenized body of the given DEFINE name
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_defines"></A>
NodeList_ptr <I></I>
<B>SymbCache_get_defines</B>(
  const SymbCache_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returned instance belongs to self, do not destroy or 
  change it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_input_symbols"></A>
NodeList_ptr <I></I>
<B>SymbCache_get_input_symbols</B>(
  const SymbCache_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Only input variables and DEFINEs can occur within the
  returned list. Returned list belongs to self, do not destroy it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_input_vars"></A>
NodeList_ptr <I></I>
<B>SymbCache_get_input_vars</B>(
  const SymbCache_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returned instance belongs to self, do not destroy or 
  change it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_state_input_symbols"></A>
NodeList_ptr <I></I>
<B>SymbCache_get_state_input_symbols</B>(
  const SymbCache_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Only DEFINEs whose body contains both state and input
  vars can occur within the returned list. Returned list belongs to
  self, do not destroy it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_state_symbols"></A>
NodeList_ptr <I></I>
<B>SymbCache_get_state_symbols</B>(
  const SymbCache_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Only state variables and DEFINEs can occur within the
  returned list. Returned list belongs to self, do not destroy it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_state_vars"></A>
NodeList_ptr <I></I>
<B>SymbCache_get_state_vars</B>(
  const SymbCache_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returned instance belongs to self, do not destroy or 
  change it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_var_type"></A>
SymbType_ptr <I></I>
<B>SymbCache_get_var_type</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns the type of a given variable
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_get_vars"></A>
NodeList_ptr <I></I>
<B>SymbCache_get_vars</B>(
  const SymbCache_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returned instance belongs to self, do not destroy or 
  change it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_is_symbol_constant"></A>
boolean <I></I>
<B>SymbCache_is_symbol_constant</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is a declared
  constant
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_is_symbol_declared"></A>
boolean <I></I>
<B>SymbCache_is_symbol_declared</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is declared
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_is_symbol_define"></A>
boolean <I></I>
<B>SymbCache_is_symbol_define</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is a declared
  DEFINE
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_is_symbol_input_var"></A>
boolean <I></I>
<B>SymbCache_is_symbol_input_var</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is an input
  variable.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_is_symbol_state_var"></A>
boolean <I></I>
<B>SymbCache_is_symbol_state_var</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is a state variable.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_is_symbol_var"></A>
boolean <I></I>
<B>SymbCache_is_symbol_var</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is either a state or
  an input variable.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_list_contains_input_var"></A>
boolean <I></I>
<B>SymbCache_list_contains_input_var</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const NodeList_ptr  <b>var_list</b> <i></i>
)
</pre>
<dd> The given list of variables is traversed until an input 
  variable is found
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_list_contains_state_var"></A>
boolean <I></I>
<B>SymbCache_list_contains_state_var</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const NodeList_ptr  <b>var_list</b> <i></i>
)
</pre>
<dd> The given list of variables is traversed until 
  a state variable is found
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_list_contains_undef_var"></A>
boolean <I></I>
<B>SymbCache_list_contains_undef_var</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const NodeList_ptr  <b>var_list</b> <i></i>
)
</pre>
<dd> Iterates through the elements in var_list
  checking each one to see if it is one undeclared variable.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_new_constant"></A>
void <I></I>
<B>SymbCache_new_constant</B>(
  SymbCache_ptr  <b>self</b>, <i></i>
  node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted. Multiple-time 
  declared constant are accepted, and a reference count is kept to deal with 
  them
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_new_define"></A>
void <I></I>
<B>SymbCache_new_define</B>(
  SymbCache_ptr  <b>self</b>, <i></i>
  node_ptr  <b>name</b>, <i></i>
  node_ptr  <b>ctx</b>, <i></i>
  node_ptr  <b>definition</b> <i></i>
)
</pre>
<dd> This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_new_input_var"></A>
void <I></I>
<B>SymbCache_new_input_var</B>(
  SymbCache_ptr  <b>self</b>, <i></i>
  node_ptr  <b>var</b>, <i></i>
  SymbType_ptr  <b>type</b> <i></i>
)
</pre>
<dd> This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_new_state_var"></A>
void <I></I>
<B>SymbCache_new_state_var</B>(
  SymbCache_ptr  <b>self</b>, <i></i>
  node_ptr  <b>var</b>, <i></i>
  SymbType_ptr  <b>type</b> <i></i>
)
</pre>
<dd> This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_remove_constant"></A>
void <I></I>
<B>SymbCache_remove_constant</B>(
  SymbCache_ptr  <b>self</b>, <i></i>
  node_ptr  <b>constant</b> <i></i>
)
</pre>
<dd> Removal is performed taking into account of reference
  counting, as constants can be shared among several layers. This
  (private) method can be used only by SymbLayer, otherwise the
  resulting status will be corrupted.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_remove_define"></A>
void <I></I>
<B>SymbCache_remove_define</B>(
  SymbCache_ptr  <b>self</b>, <i></i>
  node_ptr  <b>define</b> <i></i>
)
</pre>
<dd> This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbCache_remove_var"></A>
void <I></I>
<B>SymbCache_remove_var</B>(
  SymbCache_ptr  <b>self</b>, <i></i>
  node_ptr  <b>var</b> <i></i>
)
</pre>
<dd> This (private) method can be used only by SymbLayer,
  otherwise the resulting status will be corrupted.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_can_declare_constant"></A>
boolean <I></I>
<B>SymbLayer_can_declare_constant</B>(
  const SymbLayer_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Since more than one layer can declare the same constants, 
  this method might return true even if another layer already contain the 
  given constant. If the constant had already been declared within self, 
  false is returned.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_can_declare_define"></A>
boolean <I></I>
<B>SymbLayer_can_declare_define</B>(
  const SymbLayer_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol does not exist within
  the symbol table which self belongs to. Returns false if the symbol
  was already declared.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_can_declare_var"></A>
boolean <I></I>
<B>SymbLayer_can_declare_var</B>(
  const SymbLayer_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol does not exist
  within the symbol table which self belongs to. Returns
  false if the symbol was already declared.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_committed_to_enc"></A>
void <I></I>
<B>SymbLayer_committed_to_enc</B>(
  SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> This method is part of a private registration protocol
  between encodings and layers, and must be considered as a private
  method.  Every time a layer is registered (committed) within an
  enconding, the layer is notified with a call to this method from the
  encoding instance which the layer is committed to. This mechanism
  helps to detect errors when a layer in use by an encoding is removed
  and destroyed from within a symbol table. The destructor will always
  check that self is not in use by any encoding when it is invoked.
<p>

<dd> <b>See Also</b> <code><a href="#removed_from_enc">removed_from_enc</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_create"></A>
SymbLayer_ptr <I></I>
<B>SymbLayer_create</B>(
  const char* <b>name</b>, <i></i>
  const LayerInsertPolicy  <b>policy</b>, <i></i>
  SymbCache_ptr  <b>cache</b> <i></i>
)
</pre>
<dd> name is copied, the caller keeps ownership of cache.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_declare_constant"></A>
void <I></I>
<B>SymbLayer_declare_constant</B>(
  SymbLayer_ptr  <b>self</b>, <i></i>
  node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> A new constant is created
<p>

<dd> <b>See Also</b> <code><a href="#SymbLayer_can_declare_constant">SymbLayer_can_declare_constant</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_declare_define"></A>
void <I></I>
<B>SymbLayer_declare_define</B>(
  SymbLayer_ptr  <b>self</b>, <i></i>
  node_ptr  <b>name</b>, <i></i>
  node_ptr  <b>context</b>, <i></i>
  node_ptr  <b>definition</b> <i></i>
)
</pre>
<dd> A new DEFINE of a given value is created. name must be  
  contestualized, context is provided as a separated information
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_declare_input_var"></A>
void <I></I>
<B>SymbLayer_declare_input_var</B>(
  SymbLayer_ptr  <b>self</b>, <i></i>
  node_ptr  <b>var_name</b>, <i></i>
  SymbType_ptr  <b>type</b> <i></i>
)
</pre>
<dd> A new input variable is created of a given type.
  The variable type can be created with SymbType_create or returned by
  funtions SymbTablePkg_..._type. 
  The layer is responsible for destroying the variable's type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_declare_state_var"></A>
void <I></I>
<B>SymbLayer_declare_state_var</B>(
  SymbLayer_ptr  <b>self</b>, <i></i>
  node_ptr  <b>var_name</b>, <i></i>
  SymbType_ptr  <b>type</b> <i></i>
)
</pre>
<dd> A new state variable is created of a given type.
  The variable type can be created with SymbType_create or returned by
  funtions SymbTablePkg_..._type. 
  The layer is responsible for destroying the variable's type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_destroy"></A>
void <I></I>
<B>SymbLayer_destroy</B>(
  SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Class SymbLayer destructor
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_all_symbols"></A>
NodeList_ptr <I></I>
<B>SymbLayer_get_all_symbols</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Self keeps the ownership of the returned instance
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_all_vars"></A>
NodeList_ptr <I></I>
<B>SymbLayer_get_all_vars</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Self keeps the ownership of the returned instance
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_bool_input_vars_num"></A>
int <I></I>
<B>SymbLayer_get_bool_input_vars_num</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns the number of declared boolean input variables
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_bool_input_vars"></A>
NodeList_ptr <I></I>
<B>SymbLayer_get_bool_input_vars</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Self keeps the ownership of the returned instance
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_bool_state_vars_num"></A>
int <I></I>
<B>SymbLayer_get_bool_state_vars_num</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns the number of declared boolean state variables
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_bool_state_vars"></A>
NodeList_ptr <I></I>
<B>SymbLayer_get_bool_state_vars</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Self keeps the ownership of the returned instance
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_bool_vars"></A>
NodeList_ptr <I></I>
<B>SymbLayer_get_bool_vars</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> WARNING: The *caller* is responsible for destroying the
  returned instance
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_constants"></A>
NodeList_ptr <I></I>
<B>SymbLayer_get_constants</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Self keeps the ownership of the returned instance
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_defines_num"></A>
int <I></I>
<B>SymbLayer_get_defines_num</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns the number of DEFINEs.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_defines"></A>
NodeList_ptr <I></I>
<B>SymbLayer_get_defines</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Self keeps the ownership of the returned instance
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_input_vars_num"></A>
int <I></I>
<B>SymbLayer_get_input_vars_num</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns the number of declared input variables
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_input_vars"></A>
NodeList_ptr <I></I>
<B>SymbLayer_get_input_vars</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Self keeps the ownership of the returned instance
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_insert_policy"></A>
LayerInsertPolicy <I></I>
<B>SymbLayer_get_insert_policy</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> This method is thought to be used exclusively by class
  SymbTable
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_name"></A>
const char* <I></I>
<B>SymbLayer_get_name</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returned string must not be freed, it belongs to self
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_state_vars_num"></A>
int <I></I>
<B>SymbLayer_get_state_vars_num</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns the number of declared state variables.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_get_state_vars"></A>
NodeList_ptr <I></I>
<B>SymbLayer_get_state_vars</B>(
  const SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Self keeps the ownership of the returned instance
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_must_insert_before"></A>
boolean <I></I>
<B>SymbLayer_must_insert_before</B>(
  const SymbLayer_ptr  <b>self</b>, <i></i>
  const SymbLayer_ptr  <b>other</b> <i></i>
)
</pre>
<dd> Compares the insertion policies of self and other, and
  returns true if self must be inserted *before* other.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_remove_var"></A>
void <I></I>
<B>SymbLayer_remove_var</B>(
  SymbLayer_ptr  <b>self</b>, <i></i>
  node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> This method can be called only if self is not currently
  commited to any encoding
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_removed_from_enc"></A>
void <I></I>
<B>SymbLayer_removed_from_enc</B>(
  SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> This method is part of a private registration protocol
  between encodings and layers, and must be considered as a private
  method.  Every time a layer is removed (uncommitted) from an
  enconding, the layer is notified with a call to this method from the
  encoding instance which the layer is being removed from. This mechanism
  helps to detect errors when a layer in use by an encoding is removed
  and destroyed from within a symbol table. The destructor will always
  check that self is not in use by any encoding when it is invoked.
<p>

<dd> <b>See Also</b> <code><a href="#commit_to_enc">commit_to_enc</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbLayer_set_name"></A>
void <I></I>
<B>SymbLayer_set_name</B>(
  SymbLayer_ptr  <b>self</b>, <i></i>
  const char* <b>new_name</b> <i></i>
)
</pre>
<dd> This method is protected (not usable by users, only 
  used by the symbol table when renaming a layer
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_boolean_enum_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_boolean_enum_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_boolean_set_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_boolean_set_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_error_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_error_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_init"></A>
void <I></I>
<B>SymbTablePkg_init</B>(
   <b></b> <i></i>
)
</pre>
<dd> This initialisation can be performed only after
  the Node package and the variable boolean_range have been initialised.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_int_symbolic_enum_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_int_symbolic_enum_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
  Do not access the values contained in the type's body.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_integer_set_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_integer_set_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_integer_symbolic_set_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_integer_symbolic_set_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_integer_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_integer_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_no_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_no_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> This type is a type of correct expressions
  which normally do not have any time. 
  The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_pure_int_enum_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_pure_int_enum_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
  Do not access the values contained in the type's body.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_pure_symbolic_enum_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_pure_symbolic_enum_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
  Do not access the values contained in the type's body.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_quit"></A>
void <I></I>
<B>SymbTablePkg_quit</B>(
   <b></b> <i></i>
)
</pre>
<dd> WARNING: the package de-initialisation
  destroys types created with the function SymbTablePkg_..._type.

  NB: The reason behind this constrain is the following: these functions
  exploit memory sharing, and this memory is freed during
  de-initialisation.

  In any case, the de-initialisation is performed by
  system "reset" command, and this command also frees all node_ptr,
  so in any case the symbolic types will be unusable, because they 
  use node_ptr inside. 
  SO, DESTROY ALL SYMBOLIC TYPES CREATED SO FAR BEFORE THE symb_table
  PACKAGE DE-INITIALISATION!
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_real_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_real_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_statement_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_statement_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> This type is a type of correct expressions which are
  statements, like assignments, or high-level nodes like TRANS, INIT,
  etc. The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_symbolic_set_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_symbolic_set_type</B>(
   <b></b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_word_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_word_type</B>(
  int  <b>width</b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTablePkg_wordarray_type"></A>
SymbType_ptr <I></I>
<B>SymbTablePkg_wordarray_type</B>(
  int  <b>awidth</b>, <i></i>
  int  <b>vwidth</b> <i></i>
)
</pre>
<dd> The memory is shared, so you can compare pointers to
  compare types. The association is done based on the cons of awidth and vwidth.
  De-initialisation of the package destroys this type.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#symb_table.c"TARGET="ABSTRACT"><CODE>symb_table.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_create_layer"></A>
SymbLayer_ptr <I></I>
<B>SymbTable_create_layer</B>(
  SymbTable_ptr  <b>self</b>, <i></i>
  const char* <b>layer_name</b>, <i></i>
  const LayerInsertPolicy  <b>ins_policy</b> <i></i>
)
</pre>
<dd> The created layer is returned. Do not destroy the
  layer, since it belongs to self. if layer name is NULL, then a
  temporary name will be searched and a new layer will be created. To
  retrieve the layer name, query the returned SymbLayer instance.
<p>

<dd> <b>See Also</b> <code><a href="#remove_layer">remove_layer</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_create"></A>
SymbTable_ptr <I></I>
<B>SymbTable_create</B>(
   <b></b> <i></i>
)
</pre>
<dd> Class constructor
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_destroy"></A>
void <I></I>
<B>SymbTable_destroy</B>(
  SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Class destructor
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_constants_num"></A>
int <I></I>
<B>SymbTable_get_constants_num</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns the number of all declared constants
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_constants"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_constants</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returned instance belongs to self, do not destroy or 
  change it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_define_body"></A>
node_ptr <I></I>
<B>SymbTable_get_define_body</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns the body of the given DEFINE name
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_define_context"></A>
node_ptr <I></I>
<B>SymbTable_get_define_context</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns the context of the given DEFINE name
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_define_flatten_body"></A>
node_ptr <I></I>
<B>SymbTable_get_define_flatten_body</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns the flattenized body of the given DEFINE name
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_defines_num"></A>
int <I></I>
<B>SymbTable_get_defines_num</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns the number of all DEFINEs
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_defines"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_defines</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returned instance belongs to self, do not destroy or 
  change it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_input_symbols"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_input_symbols</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Only input variables and DEFINEs can occur within the
  returned list. Returned list belongs to self, do not destroy it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_input_vars_num"></A>
int <I></I>
<B>SymbTable_get_input_vars_num</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns the number of all declared input variables
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_input_vars"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_input_vars</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returned instance belongs to self, do not destroy or 
  change it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_layers_input_symbols"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_layers_input_symbols</B>(
  SymbTable_ptr  <b>self</b>, <i></i>
  const array_t* <b>layer_names</b> <i></i>
)
</pre>
<dd> Everytime this method is called, it will create and
  calculate a new list. layers is an array of strings terminated by NULL.
  WARNING: The returned instance must be destroyed by the caller
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_layers_state_input_symbols"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_layers_state_input_symbols</B>(
  SymbTable_ptr  <b>self</b>, <i></i>
  const array_t* <b>layer_names</b> <i></i>
)
</pre>
<dd> Everytime this method is called, it will create and
  calculate a new list. layers is an array of strings terminated by NULL.
  WARNING: The returned instance must be destroyed by the caller
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_layers_state_symbols"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_layers_state_symbols</B>(
  SymbTable_ptr  <b>self</b>, <i></i>
  const array_t* <b>layer_names</b> <i></i>
)
</pre>
<dd> Everytime this method is called, it will create and
  calculate a new list. layers is an array of strings terminated by NULL.
  WARNING: The returned instance must be destroyed by the caller
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_model_input_symbols"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_model_input_symbols</B>(
  SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> The returned instance belongs to self. Everytime this
  method is called, it will create and calculate a new list.  The
  existance of a layer called MODEL_LAYER_NAME will be checked, and if
  not found, and empty list will be returned.

  WARNING: The returned instance must be destroyed by the caller
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_model_state_input_symbols"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_model_state_input_symbols</B>(
  SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> The returned instance belongs to self. Everytime this
  method is called, it will create and calculate a new list.  The
  existance of a layer called MODEL_LAYER_NAME will be checked, and if
  not found, and empty list will be returned.

  WARNING: The returned instance must be destroyed by the caller
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_model_state_symbols"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_model_state_symbols</B>(
  SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Everytime this method is called, it will create and
  calculate a new list.  The existance of a layer called
  MODEL_LAYER_NAME will be checked, and if not found, and empty list
  will be returned.

  WARNING: The returned instance must be destroyed by the caller
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_state_input_symbols"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_state_input_symbols</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Only DEFINEs whose body contains both state and input
  vars can occur within the returned list. Returned list belongs to
  self, do not destroy it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_state_symbols"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_state_symbols</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Only state variables and DEFINEs can occur within the
  returned list. Returned list belongs to self, do not destroy it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_state_vars_num"></A>
int <I></I>
<B>SymbTable_get_state_vars_num</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns the number of all declared state variables
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_state_vars"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_state_vars</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returned instance belongs to self, do not destroy or 
  change it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_var_type"></A>
SymbType_ptr <I></I>
<B>SymbTable_get_var_type</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> The type belongs to the layer, do not destroy it.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_vars_num"></A>
int <I></I>
<B>SymbTable_get_vars_num</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns the number of all declared variables
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_get_vars"></A>
NodeList_ptr <I></I>
<B>SymbTable_get_vars</B>(
  const SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returned instance belongs to self, do not destroy or 
  change it
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_is_symbol_bool_var"></A>
boolean <I></I>
<B>SymbTable_is_symbol_bool_var</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is a variable of enum type 
  with the values 0 and 1 (boolean)
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_is_symbol_constant"></A>
boolean <I></I>
<B>SymbTable_is_symbol_constant</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is a declared
  constant
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_is_symbol_declared"></A>
boolean <I></I>
<B>SymbTable_is_symbol_declared</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is declared
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_is_symbol_define"></A>
boolean <I></I>
<B>SymbTable_is_symbol_define</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is a declared
  DEFINE
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_is_symbol_input_var"></A>
boolean <I></I>
<B>SymbTable_is_symbol_input_var</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is an input variable.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_is_symbol_state_var"></A>
boolean <I></I>
<B>SymbTable_is_symbol_state_var</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is a state variable.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_is_symbol_var"></A>
boolean <I></I>
<B>SymbTable_is_symbol_var</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returns true if the given symbol is either a state or
  an input variable.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_list_contains_input_var"></A>
boolean <I></I>
<B>SymbTable_list_contains_input_var</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const NodeList_ptr  <b>var_list</b> <i></i>
)
</pre>
<dd> The given list of variables is traversed until an input 
  variable is found
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_list_contains_state_var"></A>
boolean <I></I>
<B>SymbTable_list_contains_state_var</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const NodeList_ptr  <b>var_list</b> <i></i>
)
</pre>
<dd> The given list of variables is traversed until 
  a state variable is found
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_list_contains_undef_var"></A>
boolean <I></I>
<B>SymbTable_list_contains_undef_var</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const NodeList_ptr  <b>var_list</b> <i></i>
)
</pre>
<dd> Iterates through the elements in var_list
  checking each one to see if it is one undeclared variable.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_remove_layer"></A>
void <I></I>
<B>SymbTable_remove_layer</B>(
  SymbTable_ptr  <b>self</b>, <i></i>
  SymbLayer_ptr  <b>layer</b> <i></i>
)
</pre>
<dd> The layer must be not in use by any encoding, so remove
  it from all encodings before calling this method. The removed layer
  will be no longer available after the invocation of this method.
<p>

<dd> <b>See Also</b> <code><a href="#create_layer">create_layer</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbTable_rename_layer"></A>
void <I></I>
<B>SymbTable_rename_layer</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const char* <b>layer_name</b>, <i></i>
  const char* <b>new_name</b> <i></i>
)
</pre>
<dd> Use to rename an existing layer. Useful for example to
  substitute an existing layer with another.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="SymbType_convert_right_to_left"></A>
SymbType_ptr <I></I>
<B>SymbType_convert_right_to_left</B>(
  SymbType_ptr  <b>leftType</b>, <i></i>
  SymbType_ptr  <b>rightType</b> <i></i>
)
</pre>
<dd> The implicit conversion is performed
  in accordance to the type order.
  NOTE: only memory-shared types can be given to this function.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_copy"></A>
SymbType_ptr <I></I>
<B>SymbType_copy</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> This function takes one type and returns its copy.

  Note: the body of the type is not copied, i.e. just pointer is remembered.
  See SymbType_create for more info about body.

  Note: the input type should not be a memory-shared type (since there is no
  meaning in coping a memory sharing type).
<p>

<dd> <b>Side Effects</b> allocate memory
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_destroy">SymbType_destroy</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_create_memory_sharing_type"></A>
SymbType_ptr <I></I>
<B>SymbType_create_memory_sharing_type</B>(
  SymbTypeTag  <b>tag</b>, <i></i>
  node_ptr  <b>body</b> <i></i>
)
</pre>
<dd> The difference from the public constructor is that this
  constructor marks the created type as a memory sharing type. As
  result the public constructor will not be able to destroy memory
  sharing instance of a type. Use the private constructor
  SymbType_destroy_memory_sharing_type to destroy such instances.
<p>

<dd> <b>Side Effects</b> allocate memory
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
<a href="#SymbType_destroy_memory_sharing_type">SymbType_destroy_memory_sharing_type</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_create"></A>
SymbType_ptr <I></I>
<B>SymbType_create</B>(
  SymbTypeTag  <b>tag</b>, <i></i>
  node_ptr  <b>body</b> <i></i>
)
</pre>
<dd> The tag must be a correct tag. The 'body' is the
  additional info corresponding to a particular kind of the type: for
  a enum type the body is the list of values; for "INT" or "REAL" the
  body is unused, and set to Nil; for "WORD" it is the NUMBER node
  defining the width of the type; for "WORDARRAY", the body is a pair
  of NUMBER nodes, defining the width of the address, and the width of
  the value. Set-types are used with expressions which represent a set
  values.  "NO-TYPE" is used with expressions which normally do not
  have any type such as assignments. "ERROR" type indicates an error
  (not an actual type).
  No-type, error-type and all set-types (boolean-set, integer-set,
  symbolic-set, symbolic-integer-set) should not be created with this
  constructor, but only with memory-shared function
  SymbTablePkg_..._type.  The reason behind this constrain is that
  only expressions (not variables) can have these types, therefore
  only memory-shared versions of these types are required.

  The constructor does not create a copy of the body, but just remember
  the pointer

  NB: system "reset" command destroys all node_ptr objects, including those
  used in SymbType_ptr. So destroy all symbolic types before the destruction
  of node_ptr objects, i.e. before or during "reset"
<p>

<dd> <b>Side Effects</b> allocate memory
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_destroy">SymbType_destroy</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_destroy_memory_sharing_type"></A>
void <I></I>
<B>SymbType_destroy_memory_sharing_type</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> The same as the public destructor SymbType_destroy
  but 'self' has to be created by private constructor 
  SymbType_create_memory_sharing_type only.
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create_memory_sharing_type">SymbType_create_memory_sharing_type</a>
<a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_destroy"></A>
void <I></I>
<B>SymbType_destroy</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Deallocate the memory. The destructor 
  does not deallocate memory from the type's body (since the
  constructor did not created the body).

  NOTE: If self is a memory sharing type instance, i.e. a type returned by 
  SymbTablePkg_..._type functions then the destructor will not delete 
  the type.
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_generate_all_word_values"></A>
node_ptr <I></I>
<B>SymbType_generate_all_word_values</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Genereate and returns a list of all possible values 
  of a particular Word type
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_get_enum_type_values"></A>
node_ptr <I></I>
<B>SymbType_get_enum_type_values</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> The given type has to be a ENUM type.
  The return list is a list of all possible values of a enum type. This list
  was provided during construction.
  
  NB: Memory sharing types do not have particular values, since they
  are "simplified".
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_get_greater"></A>
SymbType_ptr <I></I>
<B>SymbType_get_greater</B>(
  SymbType_ptr  <b>type1</b>, <i></i>
  SymbType_ptr  <b>type2</b> <i></i>
)
</pre>
<dd> The implicit conversion is performed
  in accordance to the type order.
  NOTE: only memory-shared types can be given to this function.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_get_minimal_common"></A>
SymbType_ptr <I></I>
<B>SymbType_get_minimal_common</B>(
  SymbType_ptr  <b>type1</b>, <i></i>
  SymbType_ptr  <b>type2</b> <i></i>
)
</pre>
<dd> The implicit conversion is performed
  in accordance to the type order.
  NOTE: only memory-shared types can be given to this function.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_get_tag"></A>
SymbTypeTag <I></I>
<B>SymbType_get_tag</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns the tag (the kind) of the type
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_get_word_line_number"></A>
int <I></I>
<B>SymbType_get_word_line_number</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> The body of the type, provided during construction, is
  a node NUMBER specifying the width of the Word or a node CONS
  specifying the address-value widths or WordArray.  This node was
  create during parsing and contains the line number of the type
  declaration.
  NB: The type should not be memory-sharing.
  NB: Virtually this function is used only in TypeChecker_is_type_wellformed
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_get_word_width"></A>
int <I></I>
<B>SymbType_get_word_width</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> The given type should be Word and the 
  body of the type (given to the constructor) should be NUMBER node.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_get_wordarray_awidth"></A>
int <I></I>
<B>SymbType_get_wordarray_awidth</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> .
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_get_wordarray_vwidth"></A>
int <I></I>
<B>SymbType_get_wordarray_vwidth</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> .
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_is_back_comp"></A>
boolean <I></I>
<B>SymbType_is_back_comp</B>(
  SymbType_ptr  <b>type</b> <i></i>
)
</pre>
<dd> We distinguish "old" types because we may want to turn
  off the type checking on these types for backward
  compatibility. Integer is also considered as "old", because an enum
  of integer values is always casted to Integer.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_is_boolean_enum"></A>
boolean <I></I>
<B>SymbType_is_boolean_enum</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> The kind of enum-type is analysed in the constructor.
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_is_error"></A>
boolean <I></I>
<B>SymbType_is_error</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Error type is used to indicate an error
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_is_int_symbolic_enum"></A>
boolean <I></I>
<B>SymbType_is_int_symbolic_enum</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> The kind of enum-type is analysed in the constructor.
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_is_pure_int_enum"></A>
boolean <I></I>
<B>SymbType_is_pure_int_enum</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> The kind of enum-type is analysed in the constructor.
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_is_pure_symbolic_enum"></A>
boolean <I></I>
<B>SymbType_is_pure_symbolic_enum</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> The kind of enum-type is analysed in the constructor.
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_is_set"></A>
boolean <I></I>
<B>SymbType_is_set</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns true, if the type is one of the set-types, i.e.
  boolean-set, integer-set, symbolic-set, integer-symbolic-set, and
  false otherwise.
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_is_statement"></A>
boolean <I></I>
<B>SymbType_is_statement</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns true, if the type is a statement-type, 
  and false otherwise.
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_is_word_1"></A>
boolean <I></I>
<B>SymbType_is_word_1</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns true, if the type is a Word type and the width of 
  the word is 1. Otherwise - returns false.
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_is_word"></A>
boolean <I></I>
<B>SymbType_is_word</B>(
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Returns true, if the type is a Word type
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_create">SymbType_create</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_make_from_set_type"></A>
SymbType_ptr <I></I>
<B>SymbType_make_from_set_type</B>(
  SymbType_ptr  <b>type</b> <i></i>
)
</pre>
<dd> More precisely the following conversion takes place:
  boolean-set -> boolean
  integer-set ->integer
  symbolic-set -> symbolic-enum
  integer-symbolic-set -> integer-symbolic-set
  another type -> the same time

  The implicit conversion is performed in accordance to the type order.
  NOTE: only memory-shared types can be given to this function.
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_make_set_type">SymbType_make_set_type</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_make_memory_shared"></A>
SymbType_ptr <I></I>
<B>SymbType_make_memory_shared</B>(
  SymbType_ptr  <b>type</b> <i></i>
)
</pre>
<dd> The input type should have 
  a corresponding memory shared type. For example, function type 
  and error type do not have memory shared instances.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_make_set_type"></A>
SymbType_ptr <I></I>
<B>SymbType_make_set_type</B>(
  SymbType_ptr  <b>type</b> <i></i>
)
</pre>
<dd> The implicit conversion is performed in accordance to the type order.
  NOTE: only memory-shared types can be given to this function.
<p>

<dd> <b>See Also</b> <code><a href="#SymbType_make_type_from_set_type">SymbType_make_type_from_set_type</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="SymbType_print"></A>
void <I></I>
<B>SymbType_print</B>(
  FILE* <b>output_stream</b>, <i></i>
  SymbType_ptr  <b>self</b> <i></i>
)
</pre>
<dd> This function is made very similar to print_node.
  If a Enum type was created with SymbType_create then all its values will be 
  printed, otherwise the type was created with SymbTablePkg_..._type
  and simplified type name (instead of actual type values) is printed.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbType.c"TARGET="ABSTRACT"><CODE>SymbType.c</CODE></A>

<dt><pre>
<A NAME="symb_cache_define_to_symbols_lists"></A>
static void <I></I>
<B>symb_cache_define_to_symbols_lists</B>(
  SymbCache_ptr  <b>self</b>, <i></i>
  node_ptr  <b>define</b> <i></i>
)
</pre>
<dd> This method must be called after all symbols occuring
  directly or indirectly within its body are all declared. If one or
  more are undeclared, an internal error occurs.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="symb_cache_deinit"></A>
static void <I></I>
<B>symb_cache_deinit</B>(
  SymbCache_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Private deinitializer, called by the destructor
<p>

<dd> <b>See Also</b> <code><a href="#symb_cache_init">symb_cache_init</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="symb_cache_init"></A>
static void <I></I>
<B>symb_cache_init</B>(
  SymbCache_ptr  <b>self</b>, <i></i>
  SymbTable_ptr  <b>symb_table</b> <i></i>
)
</pre>
<dd> Private initializer, called by the constructor
<p>

<dd> <b>See Also</b> <code><a href="#symb_cache_deinit">symb_cache_deinit</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="symb_cache_lookup_symbol"></A>
static node_ptr <I></I>
<B>symb_cache_lookup_symbol</B>(
  const SymbCache_ptr  <b>self</b>, <i></i>
  const node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> Returned node can be either VAR, IVAR or CONTEXT. Value
  is searched first in the cache, then in the symbol hash
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="symb_cache_new_symbol"></A>
static void <I></I>
<B>symb_cache_new_symbol</B>(
  SymbCache_ptr  <b>self</b>, <i></i>
  node_ptr  <b>name</b>, <i></i>
  node_ptr  <b>value</b> <i></i>
)
</pre>
<dd> This takes into account also the caching of last accessed 
  value
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="symb_cache_remove_symbol"></A>
static void <I></I>
<B>symb_cache_remove_symbol</B>(
  SymbCache_ptr  <b>self</b>, <i></i>
  node_ptr  <b>name</b> <i></i>
)
</pre>
<dd> A service of the remove_* private methods
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="symb_cache_resolve_pending_defines"></A>
static void <I></I>
<B>symb_cache_resolve_pending_defines</B>(
  SymbCache_ptr  <b>self</b> <i></i>
)
</pre>
<dd> If there are pending DEFINEs that wait for an assignment 
  within the lists of state, input and state-input symbols list, they are 
  resolved and assigned.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbCache.c"TARGET="ABSTRACT"><CODE>SymbCache.c</CODE></A>

<dt><pre>
<A NAME="symb_layer_deinit"></A>
static void <I></I>
<B>symb_layer_deinit</B>(
  SymbLayer_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Called by the destructor
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="symb_layer_init"></A>
static void <I></I>
<B>symb_layer_init</B>(
  SymbLayer_ptr  <b>self</b>, <i></i>
  const char* <b>name</b>, <i></i>
  const LayerInsertPolicy  <b>policy</b>, <i></i>
  SymbCache_ptr  <b>cache</b> <i></i>
)
</pre>
<dd> Called by the constructor
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbLayer.c"TARGET="ABSTRACT"><CODE>SymbLayer.c</CODE></A>

<dt><pre>
<A NAME="symb_table_deinit"></A>
static void <I></I>
<B>symb_table_deinit</B>(
  SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Private deinitializer, called by the destructor only
<p>

<dd> <b>See Also</b> <code><a href="#symb_table_init">symb_table_init</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="symb_table_filter_layer_symbols"></A>
static NodeList_ptr <I></I>
<B>symb_table_filter_layer_symbols</B>(
  SymbTable_ptr  <b>self</b>, <i></i>
  const char* <b>layer_name</b>, <i></i>
  NodeList_ptr  <b>symbols</b> <i></i>
)
</pre>
<dd> An empty list is returned if the model layer has not been 
  created yet. The caller is responsible for destroying the returned list
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="symb_table_filter_layers_symbols"></A>
static NodeList_ptr <I></I>
<B>symb_table_filter_layers_symbols</B>(
  SymbTable_ptr  <b>self</b>, <i></i>
  const array_t* <b>layer_names</b>, <i></i>
  NodeList_ptr  <b>symbols</b> <i></i>
)
</pre>
<dd> The caller is responsible for destroying the
  returned list
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="symb_table_init"></A>
static void <I></I>
<B>symb_table_init</B>(
  SymbTable_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Private initializer, called by the constructor only
<p>

<dd> <b>See Also</b> <code><a href="#symb_table_deinit">symb_table_deinit</a>
</code>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>

<dt><pre>
<A NAME="symb_table_layer_exists"></A>
static boolean <I></I>
<B>symb_table_layer_exists</B>(
  const SymbTable_ptr  <b>self</b>, <i></i>
  const char* <b>layer_name</b> <i></i>
)
</pre>
<dd> Returns true if the given name corresponds to an already
  registered layer.
<p>

<DD> <B>Defined in </B> <A HREF="AllFile.html#SymbTable.c"TARGET="ABSTRACT"><CODE>SymbTable.c</CODE></A>


</DL>
<HR>
Last updated on 2007/05/22 16h:13
</BODY></HTML>
